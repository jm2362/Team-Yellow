* DONE Agile Manifesto
** Individuals and interactions over processes and tools
** Working software over comprehensive documentation
** Customer collaboration over contract negotiation
** Responding to change over following a plan
* DONE Agile Methods
** Customer Involvement
*** Customers should always be kept in loop so that they know what they are getting
** Incremental Delivery
*** Deliver in increments so that the customer knows what they are getting, and if anything needs to be changed, it can be done at an earlier stage
** People not process
*** Let people exercise their own creativity and not micro-manage
** Embrace Change
*** Be flexibile to change/design
** Maintain Simplicity
*** KISS (Keep it Simple Stupid), DRY (Don't Repeat Yourself)
* DONE Refactoring
** Summary: Restructuring your code without adding/removing features.
** re-organization of class hierarchy to remove duplicates
** tidying up and renaming attrivutes and methods to make them easier to understand
** replacement of function calls to library 
** replacing algorithms with faster/scalable ones
* DONE Agile Project Tracking
** User Story represents a small piece of business value that a team can deliver in an iteration
*** A feature to be implemented within an iteration
** Task
*** unit of work that completes a parent task/user story
** Block/Impediment
*** issue outside of team's control preventing progress
** Product Planning
*** maintained by product owner. longer iteration activity
** Release Planning
*** Usually done by product owner, team, and stakeholders. Define content of release with time frame
*** Done before any sprints
** Sprint Planning
*** team commits to completing a set of highest priority items
*** facilitated by scrum-master
*** break user stories up into tasks
** Hierachy of the Backlogs
*** Product Backlog
**** ranked list of feature requests
*** Release Backlog
**** subset of product backlog that will be in the next release
*** Sprint Backlog
**** subset of release backlog
** Steps of Project Tracking
*** Product Owner (Ted Lehr/Team Yellow) wants a product
**** Start making "features" (user stories) and add them to PRODUCT BACKLOG for duration of the ENTIRE project. This is ranked by priority/importance
**** At this point, he has list of user stories and is ready for a release
**** Release Planning [3/7]
***** DONE Get together as a team, manager, owner, team members, "plan" a Release.
***** DONE "Live at sangm.io" ==> "Release" [0%]
***** TODO "Get the server running" ==> "Release Backlog"
***** TODO "Set up Nginx"           ==> "Release Backlog"
***** TODO wanted to add, "Editable Divs" ==> "Product Backlog"

***** DONE Sprint Planning "Get the server running"
****** ___ASSUME__ it's already sorted by priority in the product backlog/release backlog 
****** Things to consider: Priority, "Story Points", "Time Estimate", whatever to consider is dependent on team.. 
****** Pick the top user stories from RELEASE Backlog and put them into an "iteration" (week, 2 weeks, monthly, etc)   
****** "Get the server running" ==> "High" "20 Points" "20 Hours"
****** "Set up Nginx"           ==> "High" "10 Points" "10 Hours"
****** Scrum Master at this point takes user stories from RELEASE Backlog and with the help of the team, breaks them into tasks
******* Break user story down into tasks "Get the server running" ==> User Story
******** Install Nginx
******** Look into configurations
******** Look into getting a server
******** Assign these tasks to engineers..
***** TODO Sprint Retrospective / Sprint Review
****** We talk about what went great, what went bad, and what we could improve on
****** This might also be a "demo" where product owner can sit in and put feedback into the loop.

* DONE Testing
** Validation Testing
*** "Are we building the product right"
*** Software should conform to its specifications
** Verification Testing
*** "Are we building the right product"
*** Software should do what the user really requires
** Blackbox Testing
*** Internals NOT KNOWN to the user
*** Acceptance Tests are an example of blackbox testing
*** focus on input/output behavior of the software
*** not based on how software is implemented
** Whitebox Testing
*** Internals KNOWN to the user
*** Unit Tests are an example of whitebox testing
*** focus on internal structure of the software
*** internal perspective of the system is used to design tests cases
*** goal: test all parts of code in the software
** Test Driver
*** Function that is executed during the test
** Test Stub
*** Test Fixture/Assertions
* DONE Answer question on Midterm: "Do you ever add tasks to stories in Release Planning?"    
* DONE Testing Example from Marvelous
** Whitebox Testing (Unit Testing)
*** DONE Database
**** DONE Make sure redis is online.
**** DONE Make sure Insert database works.
**** DONE Make sure deletion works.
**** DONE Make sure http://sangm.io/test123 is accepting requests
*** DONE We have to move to MySQL, Postgres, Mongodb, *DATABASE*
*** DONE Web URL / Routes 
**** route('/index') returns hello world
**** route('/domains) returns existing domains
**** route('/insert_{}Domain) inserts domain
*** ASSUME MySQL 
**** Write specific tests about how MySQL is implemented
** Blackbox Testing (Acceptance Testing, Integration Testing, realize behavior is whats important)
*** DONE User inputs businessName, businessEmail, ...; Registers their website as "franklin.sangm.io"
*** DONE Make sure "franklin.sangm.io"
* DONE Git Repository
** origin: http://github.com/jeffm/Team-Yellow.git
** upstream: http://github.com/Marvelous/Team-Yellow.git
** Working Directory
** Local Repository
** Remote/Master Repository
* DONE Business Case
** Executive Summary
*** Local business owners do not have a way to maintain online presence. Recommendation. Justification. Outcome. Blah blah.
** Issue
*** Local business owners have no easy/intuitive way of maintain their online presence. 
** Recommendation
*** The tool will handle making webistes, maintain websites, maintain the server, and have engineers available so that the business owner can have full control of their web presence without having the knowledge of web development
** Justification
*** There are other WIZIWIG editors that will enable the customer to create a website, however, that is still "work" and someone who is not proficient in computers will be unlikely to use the product. Our product will abstract away all tehchnical knowledge and leave the customer with a product that they want. The income can come from charing an inital fee of the website + domain fees, and monthly recurring charges for services offered + maintaining the server.
*** The stack will be Python(Flask) + AngularJS + nginx + puppet + CentOS(7)
*** There are no other technology like this
*** People like not having to know shit
** Anticipated Outcomes
*** The desired outcome is that the customer have a website/web application that he can fully customize every aspect without any knowledge of how it is actually created. Unlike any of the other competitors, we take 100% of the technical "debt"

** Organizatonal Impact
*** Online presence will be easier
* DONE Risk model of Waterfall / Agile
** Waterfall "Boeing"
*** Risk/Money important things
*** Need to work on 100% time.
*** Large investment of money at the end
*** Risk of failure increase overtime
** Agile
*** 
* DONE Burndown Chart
* DONE Test Mock/Test Stub/Test Driver
** Example of Test Driver/Test Stub/Mock
** Want to implement an add function. 
** Protoype: int addNums(int a, int b)
*** Test Driver ==> addNums(int a, int b)
*** Test Stub ==> assert 3 == addNumbs(1, 2)
*** Test Mock ==> Won't be on exam
**** Want to test "database", connecting to database (takes 1 second), "mock object" will always return 0 given 0
**** You use mock OBJECT to test database
**** class Database:
***** def input(1): return 0
* DONE Alpha Testing, Beta Testing
** Users of the software work with the development team to test the software at the developerâ€™s site.
** A release of the software is made available to users to allow them to experiment and to raise problems that they discover with the system developers.
** Alpha: local
** Beta: Group
** Acceptance: Boss
* IN-PROGRESS Process Models for Marvelous
* TODO System Boundary Example of Marvelous
* TODO Inspections/Finding Bugs in Code
